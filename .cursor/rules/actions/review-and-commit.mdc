---
alwaysApply: false
---

# Review and Commit Workflow (SDLC CLI)

When this action is invoked, follow these steps sequentially. This workflow is for the `sdlc-cli` project.

## Step 1: Check Current Branch

1. Run `git branch --show-current` or `git status` to determine the current branch name.
2. If the current branch is `main` (or `master`):
   - Notify the user: "ERROR: You are currently on the main branch. The main branch is protected and commits are not allowed. All work must be done on a feature or maintenance branch. Please switch to an appropriate branch before proceeding."
   - **STOP** - Do not proceed. The user must switch branches first.
3. Verify the branch name follows naming conventions:
   - Feature branches: `feature/description` or `feat/description`
   - Maintenance branches: `maintenance/description` or `fix/description` or `bugfix/description`
   - If the branch doesn't follow conventions, warn the user but allow them to proceed.

## Step 2: Check for Unstaged / Uncommitted Changes

If not on main branch, proceed with the following:

1. Run `git status` to check for changes to commit. This includes:
   - **Untracked files** (new files not yet added)
   - **Unstaged changes** (modified or deleted tracked files not yet added to the index)
   - Optionally **staged changes** (already `git add`ed but not committed)
2. If there is nothing to commit (no untracked files, no unstaged changes, and no staged changes):
   - Notify the user: "No unstaged or uncommitted changes found. Nothing to commit."
   - **STOP**
3. If there are untracked files and/or unstaged changes:
   - List all such files for the user (e.g. from `git status` under "Changes not staged" and "Untracked files").
   - Proceed to Step 3.

## Step 3: Examine the Work Done

1. For each file with changes (unstaged or untracked), read its contents or review the diff:
   - Use `git diff` to see what has changed.
   - Read modified files to understand the changes made.
   - Summarize the work that has been completed:
     - What features were added?
     - What bugs were fixed?
     - What refactoring was done?
     - What documentation was updated?
     - What commands or workflows were added or modified?
     - What version managers or issue trackers were implemented?
2. Create a clear, concise summary of the work completed.

## Step 4: Compare with Open GitHub Issues

1. Fetch the repository's GitHub issues using SDLC CLI work commands:
   - **Primary method**: Use `sdlc w:list` (or `sdlc work list`) to list open issues
   - **Alternative**: Use `gh issue list` if SDLC CLI is not available
   - **Fallback**: Use GitHub API if neither CLI is available
2. Compare the work summary from Step 3 against all open issues:
   - Look for issues that describe the same work or are addressed by the changes.
   - Match by:
     - Feature descriptions
     - Bug descriptions
     - Component/file names mentioned
     - Similar functionality
     - Command or workflow names
3. Identify any matching issues by their issue numbers.

## Step 5: Handle Issue Association

**REQUIREMENT: ALL commit messages MUST include an issue number. No exceptions.**

**If matching issues are found:**
- Select the most relevant issue (or issues if multiple apply).
- **Before committing, update the issue(s) to reflect work status:**
  - If this is the start of work on the issue: `sdlc w:update --id <number> --assignee CobyR --label "In Progress"`
  - If this completes the work: `sdlc w:update --id <number> --label "Fixed" --remove-label "In Progress"`
- Create a commit message that incorporates the issue number(s):
  - Format: `[#ISSUE_NUMBER] Brief description of changes`
  - Example: `[#42] Add Python version manager implementation`
  - If multiple issues: `[#42][#43] Implement version manager and GitHub issues tracker`
- **DO NOT proceed without an issue number in the commit message.**

**If no matching issues are found:**
1. **YOU MUST create a new GitHub issue** using SDLC CLI that describes the work:
   - Use `sdlc w:create` (or `sdlc work create`) command
   - Title: Brief description of what was done
   - Body: Detailed description based on the work summary from Step 3
   - Assign to yourself: `--assignee CobyR`
   - Include relevant labels (e.g., "feature", "bug", "enhancement", "In Progress")
   - Example: `sdlc w:create --title "Brief description" --body "Detailed description" --assignee CobyR --label "feature" --label "In Progress"`
2. **If the work is already complete when creating the issue:**
   - Mark as fixed: `sdlc w:update --id <new-issue-number> --label "Fixed" --remove-label "In Progress"`
3. **DO NOT mark the issue as closed** - leave it open (it will be closed when released).
4. Incorporate the new issue number into the commit message:
   - Format: `[#NEW_ISSUE_NUMBER] Brief description of changes`
   - Example: `[#45] Refactor issue tracker abstraction`
5. **DO NOT proceed to commit without creating an issue first.**

**Critical Rule**: If you cannot access GitHub issues (SDLC CLI not available, GitHub CLI not available, no API access, etc.), you MUST notify the user and **STOP**. Do not commit without an issue number. The user must manually create an issue or fix the GitHub access problem before proceeding.

**Preferred Method**: Always use `sdlc w:list` and `sdlc w:create` commands when working on the sdlc-cli project itself, as this demonstrates the tool's capabilities and ensures consistency.

## Step 6: Run Type Check

1. Run TypeScript type checking to ensure there are no type errors:
   ```bash
   npm run build
   ```
   Or for type checking only:
   ```bash
   npx tsc --noEmit
   ```
2. **If type-check fails:**
   - Display the TypeScript errors to the user
   - **STOP** and notify the user: "TypeScript errors found. Please fix these errors before committing. Run 'npm run build' to see the errors."
   - Do not proceed to Step 7 (staging and committing)
3. **If type-check passes:**
   - Proceed to Step 7 (Stage and Commit Changes)

## Step 7: Stage and Commit Changes

1. Stage all untracked and unstaged files: `git add .` or `git add -A`
2. Create the commit with the message from Step 5:
   ```bash
   git commit -m "YOUR_COMMIT_MESSAGE_HERE"
   ```
3. Confirm the commit was successful by running `git log -1` or `git status`.

## Step 8: Push to Origin

1. Push the commit to the remote repository on the current branch:
   ```bash
   git push origin $(git branch --show-current)
   ```
   Or more explicitly:
   ```bash
   git push origin HEAD
   ```
2. Confirm the push was successful.
3. Notify the user of completion:
   - Show the commit hash
   - Show the commit message
   - Mention which issue(s) were associated
   - Confirm the branch was pushed to origin

## Error Handling

- If any step fails, stop and notify the user with:
  - What step failed
  - The error message
  - Suggested remediation if applicable
- Do not proceed with subsequent steps if a critical step fails.
- **Important**: Type-check failures (Step 6) are considered critical - do not commit code with TypeScript errors.

## Notes

- **MANDATORY**: ALL commit messages MUST include an issue number in the format `[#ISSUE_NUMBER]`. This is a hard requirement with no exceptions.
- Always use descriptive commit messages that explain what was done and why.
- **DO NOT commit without an issue number** - if GitHub access is unavailable, you must stop and notify the user to fix the access issue or manually create an issue.
- The commit message should be clear enough that someone reviewing the git log can understand what changed.
- **Type Safety**: Always run `npm run build` before committing to catch TypeScript errors early. This prevents build failures in CI/CD pipelines.
- This workflow is specific to the `sdlc-cli` project and should be used when working within this repository.
- For CLI projects, focus on command implementations, library abstractions, and workflow enforcement features.
- When creating new issues for work, leave them open (do not close immediately) - they will be marked with the "fixed" label and closed when released.
