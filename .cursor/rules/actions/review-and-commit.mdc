---
alwaysApply: false
---

# Review and Commit Workflow (SDLC CLI)

When this action is invoked, follow these steps sequentially. This workflow is for the `sdlc-cli` project.

## Step 1: Check Current Branch

1. Run `git branch --show-current` or `git status` to determine the current branch name.
2. If the current branch is `main` (or `master`):
   - Notify the user: "ERROR: You are currently on the main branch. The main branch is protected and commits are not allowed. All work must be done on a feature or maintenance branch. Please switch to an appropriate branch before proceeding."
   - **STOP** - Do not proceed. The user must switch branches first.
3. Verify the branch name follows naming conventions:
   - Feature branches: `feature/description` or `feat/description`
   - Maintenance branches: `maintenance/description` or `fix/description` or `bugfix/description`
   - If the branch doesn't follow conventions, warn the user but allow them to proceed.

## Step 2: Check for Unstaged Files

If not on main branch, proceed with the following:

1. Run `git status` to check for unstaged or modified files.
2. If there are no unstaged files:
   - Notify the user: "No unstaged changes found. Nothing to commit."
   - **STOP**
3. If there are unstaged files:
   - List all unstaged files for the user.
   - Proceed to Step 3.

## Step 3: Examine the Work Done

1. For each unstaged file, read its contents or review the diff:
   - Use `git diff` to see what has changed.
   - Read modified files to understand the changes made.
   - Summarize the work that has been completed:
     - What features were added?
     - What bugs were fixed?
     - What refactoring was done?
     - What documentation was updated?
     - What commands or workflows were added or modified?
     - What version managers or issue trackers were implemented?
2. Create a clear, concise summary of the work completed.

## Step 4: Compare with Open GitHub Issues

1. Fetch the repository's GitHub issues. You may need to:
   - Use GitHub API (if available via tools)
   - Check if there's a `.github/ISSUES` directory or similar
   - Use terminal commands like `gh issue list` if GitHub CLI is available
2. Compare the work summary from Step 3 against all open issues:
   - Look for issues that describe the same work or are addressed by the changes.
   - Match by:
     - Feature descriptions
     - Bug descriptions
     - Component/file names mentioned
     - Similar functionality
     - Command or workflow names
3. Identify any matching issues by their issue numbers.

## Step 5: Handle Issue Association

**If matching issues are found:**
- Select the most relevant issue (or issues if multiple apply).
- Create a commit message that incorporates the issue number(s):
  - Format: `[#ISSUE_NUMBER] Brief description of changes`
  - Example: `[#42] Add Python version manager implementation`
  - If multiple issues: `[#42][#43] Implement version manager and GitHub issues tracker`

**If no matching issues are found:**
1. Create a new GitHub issue that describes the work:
   - Title: Brief description of what was done
   - Body: Detailed description based on the work summary from Step 3
   - Include relevant labels if possible (e.g., "feature", "bug", "sdlc-cli", "enhancement")
2. Mark the issue as completed/closed immediately after creation.
3. Incorporate the new issue number into the commit message:
   - Format: `[#NEW_ISSUE_NUMBER] Brief description of changes`
   - Example: `[#45] Refactor issue tracker abstraction`

## Step 6: Run Type Check

1. Run TypeScript type checking to ensure there are no type errors:
   ```bash
   npm run build
   ```
   Or for type checking only:
   ```bash
   npx tsc --noEmit
   ```
2. **If type-check fails:**
   - Display the TypeScript errors to the user
   - **STOP** and notify the user: "TypeScript errors found. Please fix these errors before committing. Run 'npm run build' to see the errors."
   - Do not proceed to Step 7 (staging and committing)
3. **If type-check passes:**
   - Proceed to Step 7 (Stage and Commit Changes)

## Step 7: Stage and Commit Changes

1. Stage all unstaged files: `git add .` or `git add -A`
2. Create the commit with the message from Step 5:
   ```bash
   git commit -m "YOUR_COMMIT_MESSAGE_HERE"
   ```
3. Confirm the commit was successful by running `git log -1` or `git status`.

## Step 8: Push to Origin

1. Push the commit to the remote repository on the current branch:
   ```bash
   git push origin $(git branch --show-current)
   ```
   Or more explicitly:
   ```bash
   git push origin HEAD
   ```
2. Confirm the push was successful.
3. Notify the user of completion:
   - Show the commit hash
   - Show the commit message
   - Mention which issue(s) were associated
   - Confirm the branch was pushed to origin

## Error Handling

- If any step fails, stop and notify the user with:
  - What step failed
  - The error message
  - Suggested remediation if applicable
- Do not proceed with subsequent steps if a critical step fails.
- **Important**: Type-check failures (Step 6) are considered critical - do not commit code with TypeScript errors.

## Notes

- Always use descriptive commit messages that explain what was done and why.
- If unable to access GitHub issues (no API access, CLI not available, etc.), notify the user and proceed with a descriptive commit message without issue numbers, suggesting manual issue creation.
- The commit message should be clear enough that someone reviewing the git log can understand what changed.
- **Type Safety**: Always run `npm run build` before committing to catch TypeScript errors early. This prevents build failures in CI/CD pipelines.
- This workflow is specific to the `sdlc-cli` project and should be used when working within this repository.
- For CLI projects, focus on command implementations, library abstractions, and workflow enforcement features.
