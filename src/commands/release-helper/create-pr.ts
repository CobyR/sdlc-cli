import {Command, Flags} from '@oclif/core'
import {createPR, pushBranch} from '../../lib/git/pr'
import {getIssueTracker, SupportedTracker} from '../../lib/issue-tracker'
import {getChangesSinceMain, categorizeChanges, CategorizedChanges} from '../../lib/git/changes'
import {isOnMainBranch} from '../../lib/git/branch'

export default class CreatePr extends Command {
  static description = 'Create PR for current branch'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --title "My Release"',
  ]

  static flags = {
    title: Flags.string({
      char: 't',
      description: 'PR title (if not provided, will be generated)',
    }),
    tracker: Flags.string({
      description: 'Issue tracker to use',
      options: ['github'],
      default: 'github',
    }),
    base: Flags.string({
      char: 'b',
      description: 'Base branch for PR',
      default: 'main',
    }),
  }

  async run(): Promise<void> {
    const {flags} = await this.parse(CreatePr)

    if (await isOnMainBranch()) {
      this.error('âŒ Cannot create PR from main branch!')
    }

    // Get work items and git changes
    this.log('ðŸ“Š Analyzing changes and work items...')

    const tracker = Array.isArray(flags.tracker) ? flags.tracker[0] : flags.tracker
    const issueTracker = getIssueTracker((tracker || 'github') as SupportedTracker)
    const workItems = await issueTracker.getFixedIssues()

    const changes = await getChangesSinceMain()
    const categorized = categorizeChanges(changes)

    // Generate PR title
    let title = flags.title
    if (!title) {
      title = this.generateTitle(workItems, categorized)
      this.log(`ðŸ“ Generated title: ${title}`)
    }

    // Generate PR description
    const description = this.generateDescription(workItems, categorized)

    // Push branch
    this.log('ðŸ“¤ Pushing branch...')
    await pushBranch()

    // Create PR
    this.log('ðŸ“ Creating Pull Request...')
    const prUrl = await createPR(title, description, flags.base)

    this.log(`âœ… Pull Request created successfully!`)
    this.log(`   ${prUrl}`)

    if (workItems.length > 0) {
      this.log(`\nðŸ“‹ Included ${workItems.length} work items`)
    }

    const totalObjects = Object.keys(categorized).length
    if (totalObjects > 0) {
      this.log(`ðŸ”§ Updated ${totalObjects} object categories`)
    }
  }

  private generateTitle(workItems: any[], categorized: CategorizedChanges): string {
    if (workItems.length === 0) {
      return 'Release with enhancements and bug fixes'
    }

    // Simple title generation - can be enhanced with AI later
    const mainTheme = workItems[0]?.title || 'Release'
    return `Release: ${mainTheme.substring(0, 60)}`
  }

  private generateDescription(workItems: any[], categorized: CategorizedChanges): string {
    let description = '# Release Summary\n\n'

    // Add work items section
    if (workItems.length > 0) {
      description += '## ðŸŽ¯ Work Items Included\n\n'
      workItems.forEach(item => {
        description += `- **[${item.id}](${item.url || '#'}):** ${item.title}\n`
      })
      description += '\n'
    }

    // Add object updates section
    if (Object.keys(categorized).length > 0) {
      description += '## ðŸ”§ Objects Updated\n\n'
      for (const [objectType, changes] of Object.entries(categorized)) {
        const changeData = changes as {added: string[]; modified: string[]; deleted: string[]}
        const total = changeData.added.length + changeData.modified.length + changeData.deleted.length
        if (total > 0) {
          description += `### ${objectType}\n`
          if (changeData.added.length > 0) {
            description += `- **Added (${changeData.added.length}):**\n`
            changeData.added.forEach((file: string) => {
              description += `  - \`${file}\`\n`
            })
          }
          if (changeData.modified.length > 0) {
            description += `- **Modified (${changeData.modified.length}):**\n`
            changeData.modified.forEach((file: string) => {
              description += `  - \`${file}\`\n`
            })
          }
          if (changeData.deleted.length > 0) {
            description += `- **Deleted (${changeData.deleted.length}):**\n`
            changeData.deleted.forEach((file: string) => {
              description += `  - \`${file}\`\n`
            })
          }
          description += '\n'
        }
      }
    }

    description += '---\n'
    description += '*This PR was automatically generated by the SDLC CLI release helper.*\n'

    return description
  }
}

